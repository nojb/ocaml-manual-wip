<!DOCTYPE html>
<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.36">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>Chapter 21 Native debugging (gdb, lldb)</title>
</head>
<body>
<a href="debugger.html"><img src="previous_motif.svg" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.svg" alt="Up"></a>
<a href="profil.html"><img src="next_motif.svg" alt="Next"></a>
<hr>
<h1 class="chapter" id="sec485">Chapter 21 Native debugging (gdb, lldb)</h1>
<ul>
<li><a href="native-debugger.html#s%3Anative-debugger-overview">21.1 Overview</a>
</li><li><a href="native-debugger.html#s%3Anative-debugger-compilation">21.2 Compiling for Debugging</a>
</li><li><a href="native-debugger.html#s%3Anative-debugger-gdb">21.3 Using GDB</a>
</li><li><a href="native-debugger.html#s%3Anative-debugger-lldb">21.4 Using LLDB</a>
</li></ul>
<p> <a id="c:native-debugger"></a>
</p>
<h2 class="section" id="s:native-debugger-overview"><a class="section-anchor" href="#s:native-debugger-overview" aria-hidden="true">﻿</a>21.1 Overview</h2>
<p>This chapter describes the support for debugging OCaml executables built with the native-code compiler <span class="font-tt">ocamlopt</span>, using standard native debuggers like GDB or LLDB. We will call this <em>native debugging</em>, in contrast to bytecode debugging supported via <span class="font-tt">ocamldebug</span> (chapter <a href="debugger.html#c%3Adebugger">20</a>).</p><p>Native debugging is supported on Linux, macOS, and FreeBSD platforms. Windows support is not currently available.</p>
<h3 class="subsection" id="ss:native-debugger-dwarf"><a class="section-anchor" href="#ss:native-debugger-dwarf" aria-hidden="true">﻿</a>21.1.1 DWARF</h3>
<p>OCaml uses the <a href="http://dwarfstd.org/">DWARF</a> debugging format to describe the debugging information it generates. DWARF is a debugging information format used by many compilers and debuggers to support source-level debugging. It is used in the ELF and Mach-O executable formats.</p><p>The debugging information includes two key components:</p><p><span class="font-bold">Call Frame Information (CFI):</span> Describes how to unwind the call stack to generate backtraces. OCaml’s CFI information spans across language boundaries-from OCaml code into C runtime functions and through Foreign Function Interface (FFI) calls when the foreign language also provides CFI data.</p><p><span class="font-bold">Source Line Mapping:</span> Maps each machine instruction back to its originating source location, enabling debuggers to display OCaml source code and supporting source-level stepping. For example, the instruction at memory address <span class="font-tt">0xdeadbeef</span> might map to <span class="font-tt">myprogram.ml:42</span>.</p><p>OCaml defines its own calling convention detailing how arguments are passed to
functions, how values are returned from functions, and how registers are used. This
information is architecture specific and is documented in the source code files
<em>asmcomp/&lt;ARCH&gt;/proc.ml</em> for each architecture.</p>
<h3 class="subsection" id="ss:native-debugger-name-mangling"><a class="section-anchor" href="#ss:native-debugger-name-mangling" aria-hidden="true">﻿</a>21.1.2 Name Mangling</h3>
<p>When OCaml compiles source code, it transforms language constructs like functions and module names into <em>mangled names</em> that appear in the final executable. These mangled names serve several purposes:</p><ul class="itemize"><li class="li-itemize">They ensure symbol uniqueness in the compiled binary
</li><li class="li-itemize">They encode module structure and namespace information
</li><li class="li-itemize">They appear in debugger output such as backtraces and symbol lists
</li><li class="li-itemize">They can be used to set breakpoints when source file information isn’t available
</li></ul><p>Current mangling scheme for OCaml 5.3 onwards:
</p><ul class="itemize"><li class="li-itemize">Linux: <span class="font-tt">caml&lt;MODULE_NAME&gt;.&lt;FUNCTION_NAME&gt;_&lt;NNN&gt;</span>
</li><li class="li-itemize">macOS and Windows MSVC: <span class="font-tt">caml&lt;MODULE_NAME&gt;$&lt;FUNCTION_NAME&gt;_&lt;NNN&gt;</span>
</li></ul><p>where <span class="font-tt">NNN</span> is a unique generated number.</p><p><span class="font-bold">Example:</span> A function <span class="font-tt">fib</span> in module <span class="font-tt">MyMath</span> might become <span class="font-tt">camlMyMath.fib_271</span> on Linux or <span class="font-tt">camlMyMath$fib_271</span> on macOS.</p><p><span class="font-bold">Note:</span> OCaml versions before 5.1.1 used double underscores: <span class="font-tt">caml&lt;MODULE_NAME&gt;__&lt;FUNCTION_NAME&gt;_&lt;NNN&gt;</span>.</p>
<h3 class="subsection" id="ss:native-debugger-frame-pointers"><a class="section-anchor" href="#ss:native-debugger-frame-pointers" aria-hidden="true">﻿</a>21.1.3 Frame Pointers</h3>
<p>Frame pointers provide an alternative method for debuggers to walk the
call stack. OCaml supports frame pointers on AMD64 and ARM64 platforms.</p><p>With frame pointers, each function maintains a <em>frame pointer</em> that points to
the base of its stack frame (the memory region allocated for that function’s
local variables and call information also known as the activation frame or
activation record). By chaining these pointers together with return addresses,
debuggers can reconstruct the complete call stack.</p><p>Frame pointers are optional (not necessary for debugging),
and must be explicitly enabled during compiler configuration
(see Profiling section <a href="profil.html#s%3Aocamlprof-compiling-perf">22.2.2</a> for details).</p>
<h2 class="section" id="s:native-debugger-compilation"><a class="section-anchor" href="#s:native-debugger-compilation" aria-hidden="true">﻿</a>21.2 Compiling for Debugging</h2>
<p>Before debugging OCaml programs, the native compiler <span class="font-tt">ocamlopt</span> must be installed with CFI support, which it is by default. You can also explicitly control
this with the <span class="font-tt">--enable-cfi</span> configure flag when building the compiler.</p><p>To perform source-level debugging, compile all code with the <span class="font-tt">-g</span> flag, this records DWARF information for exception backtraces, and generates line information for mapping between assembly and source locations in OCaml. Compiling with <span class="font-tt">-g</span> entails no runtime penalty but will generate larger binaries as they include sections for debugging information. Note that OCaml libraries and other dependencies, need to be compiled with DWARF debugging information, failure to do so will lose source-level debugging features for those sections of code.</p><p>Debuggers need access to source files referenced in the DWARF information. For dependencies, consider using opam’s build directory preservation:</p><pre># First tell opam to keep the source code
$ export OPAMKEEPBUILDDIR=1

# Then, reinstall the packages to force redownloading the sources
$ opam switch reinstall

# Source code for packages will appear inside the opam switch
# in a build directory. e.g. _opam/.opam-switch/build/ for a
# local switch or ~/.opam/&lt;switch_name&gt;/.opam-switch/build
</pre><p>
The following sections demonstrate debugging OCaml programs with GDB and LLDB, showing common workflows and expected outputs.</p>
<h2 class="section" id="s:native-debugger-gdb"><a class="section-anchor" href="#s:native-debugger-gdb" aria-hidden="true">﻿</a>21.3 Using GDB</h2>
<p>Here we walk through debugging a simple OCaml program using GDB on Linux, showing the commands to use and the expected outputs. Note this session uses Ubuntu 24.04 LTS on AMD64 with OCaml 5.4.</p><p>Consider the following program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib.ml *)</span>
<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n =
  <span class="ocamlkeyword">if</span> n = 0 <span class="ocamlkeyword">then</span> 0
  <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">if</span> n = 1 <span class="ocamlkeyword">then</span> 1
  <span class="ocamlkeyword">else</span> fib (n-1) + fib (n-2)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = fib 20 <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(20) = %d"</span> r

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><p>Compile this program with <span class="font-tt">ocamlopt</span> like so:</p><pre>$ ocamlopt -g -o fib.exe fib.ml
$ ./fib.exe 20
fib(20) = 6765
</pre><p>
When run this program prints the 20th Fibonacci number. The use of recursion is an excuse to inspect the call stack. Startup a GDB session for this program:</p><pre>$ gdb ./fib.exe
</pre><p>
Breakpoints can be set using either the mangled names produced by the compiler or a combination of file name and line number. For example:</p><pre>(gdb) break camlFib.fib_     # press tab
(gdb) break camlFib.fib_271  # 271 happens to be the unique number generated
Breakpoint 1 at 0x3cd50: file fib.ml, line 2.

(gdb) break fib.ml:7         # breakpoint for main function
Breakpoint 2 at 0x3cdc0: file fib.ml, line 7.
</pre><p>
Now we can run the program and print a backtrace.</p><pre>(gdb) run
Starting program: fib.exe
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 2, camlFib.main_273 () at fib.ml:7
7	let main () =
(gdb) continue
Continuing.

Breakpoint 1, camlFib.fib_271 () at fib.ml:2
2	let rec fib n =
(gdb) backtrace
#0  camlFib.fib_270 () at fib.ml:2
#1  0x0000555555590de1 in camlFib.main_273 () at fib.ml:7
#2  0x0000555555590e86 in camlFib.entry () at fib.ml:11
#3  0x000055555558eaa7 in caml_program ()
#4  &lt;signal handler called&gt;
#5  0x00005555555de126 in caml_startup_common (pooling=&lt;optimised out&gt;, argv=0x7fffffffe3f8)
    at runtime/startup_nat.c:132
#6  caml_startup_common (argv=0x7fffffffe3f8, pooling=&lt;optimised out&gt;) at runtime/startup_nat.c:88
#7  0x00005555555de19f in caml_startup_exn (argv=&lt;optimised out&gt;) at runtime/startup_nat.c:139
#8  caml_startup (argv=&lt;optimised out&gt;) at runtime/startup_nat.c:144
#9  caml_main (argv=&lt;optimised out&gt;) at runtime/startup_nat.c:151
#10 0x000055555558e892 in main (argc=&lt;optimised out&gt;, argv=&lt;optimised out&gt;) at runtime/main.c:37
</pre><p>
There is also basic support for printing OCaml values using the built-in Python scripting in GDB and <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/gdb.py">tools/gdb.py</a>. Either find that file in your opam switch e.g. <span class="font-tt"> /.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/gdb.py</span> or download it from GitHub. Then load it into GDB using ‘source‘.</p><pre>(gdb) source ~/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/gdb.py
OCaml support module loaded. Values of type 'value' will now
print as OCaml values, there is a $Array() convenience function,
and an 'ocaml' command is available for heap exploration
(see 'help ocaml' for more information).

(gdb) p (value)$rax
$1 = caml:14

</pre><p>
We can also print other kinds of OCaml values. In order to illustrate this, consider the following program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* test_blocks.ml *)</span>
<span class="ocamlkeyword">type</span> t = {s : string; i : int}

<span class="ocamlkeyword">let</span> main a b =
  print_endline <span class="ocamlstring">"Hello, world!"</span>;
  print_endline a;
  print_endline b.s

<span class="ocamlkeyword">let</span> _ = main <span class="ocamlstring">"foo"</span> {s = <span class="ocamlstring">"bar"</span>; i = 42}</div></div>

</div><p>Compile this program with <span class="font-tt">ocamlopt</span> and load it into GDB:</p><pre>$ ocamlopt -g -o test_blocks.exe test_blocks.ml
$ gdb ./test_blocks.exe
(gdb) source ~/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/gdb.py
...
(gdb) break camlTest_blocks.main_273
Breakpoint 1 at 0x16db0: file test_blocks.ml, line 4.
(gdb) run
...
Breakpoint 1, camlTest_blocks.main_273 () at test_blocks.ml:4
4	let main a b =
(gdb) p (value)$rax      # Print out the first argument to main
$1 = caml(-):'foo'&lt;3&gt;
(gdb) p (value)$rbx      # Then print the second argument
$2 = caml(-):('bar', 42) = {caml(-):'bar'&lt;3&gt;, caml:42}
</pre><p>
Note the use of AMD64 register names: <span class="font-tt">$rax</span> and <span class="font-tt">$rbx</span> to access the first and second arguments to a function. This follows the OCaml calling convention on AMD64 where <span class="font-tt">$rax</span> to <span class="font-tt">$r13</span> hold OCaml function arguments and <span class="font-tt">$rax</span> holds function results. Consult the <span class="font-tt">asmcomp/&lt;ARCH&gt;/proc.ml</span> file for a specific architecture for further information about OCaml calling conventions.</p><p>Executables may not include exact information about where to find the source code used to build them for various reasons. In GDB this appears as an absence of source listings and a ‘No such file or directory‘ warning message. In this case GDB supports different ways to tell it where to find the sources. Consult GDB’s <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Source-Path.html">Source Path</a> documentation for full details.</p><p>Returning to <span class="font-tt">fib.exe</span> from earlier, the source file has been copied to <span class="font-tt">/tmp/fib.ml</span> where GDB will not find it. Here we use the GDB command <span class="font-tt">directory</span> to tell GDB where to find the source files for <span class="font-tt">fib.ml</span> and the OCaml standard library.</p><pre>$ gdb ./fib.exe
...
(gdb) break camlFib.main_276
(gdb) break camlStdlib__Printf.fprintf_431
(gdb) run
...
Breakpoint 1, 0x00005555555921b0 in camlFib.main () at fib.ml:7
warning: 9	fib.ml: No such file or directory
# Update directories to search for source files for fib.ml and OCaml
(gdb) directory /tmp ~/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/
Source directories searched: /tmp:/home/user/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0:$cdir:$cwd
(gdb) list
4	  else if n = 1 then 1
5	  else fib (n-1) + fib (n-2)
6
7	let main () =
8	  let r = fib 20 in
9	  Printf.printf "fib(20) = %d" r
10
11	let _ = main ()
</pre>
<h3 class="subsection" id="ss:native-debugger-gdb-commands"><a class="section-anchor" href="#ss:native-debugger-gdb-commands" aria-hidden="true">﻿</a>21.3.1 GDB Commands</h3>
<p>Summary of interesting OCaml specific GDB commands:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break </span></span><span class="font-it">locspec</span></span></dt><dd class="dd-description">
Set a breakpoint at all of the code locations matching <span class="font-it">locspec</span>, e.g., Using the mangled OCaml names or specifying the linenum in the source file as <span class="font-tt">filename:linenum</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">backtrace</span></span></span></dt><dd class="dd-description">
Print the backtrace of the entire stack. This will include OCaml source references identifying which stack frame maps to a source location, e.g., <span class="font-tt">fib.ml:4</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">disassemble </span></span><span class="font-it">addresses</span></span></dt><dd class="dd-description">
Display a range of <span class="font-it">addresses</span> as machine instructions. Typically used with the mangled OCaml names to display the assembly for a function.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">info </span></span><span class="font-it">frame</span></span></dt><dd class="dd-description">
This command prints a verbose description of the selected stack frame.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">list </span></span><span class="font-it">linenum</span></span></dt><dd class="dd-description">
Print lines centered around line number <span class="font-it">linenum</span> in the current source file. This will print the source code for OCaml and the OCaml runtime written in C.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">directory </span></span><span class="font-it">dirname</span></span></dt><dd class="dd-description">
Add directory <span class="font-it">dirname</span> to the front of the source path, several directory names can be supplied separated by <span class="font-tt">:</span>. Useful when directories change between compilation and a debug session.</dd></dl><p>See the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/">Debugging with GDB</a> documentation for more details. In general the features described above work with OCaml, failing that GDB will fall back to assembly language debugging. GDB is expected to work on all supported Linux architectures.</p>
<h2 class="section" id="s:native-debugger-lldb"><a class="section-anchor" href="#s:native-debugger-lldb" aria-hidden="true">﻿</a>21.4 Using LLDB</h2>
<p>Here we will walk through debugging the earlier fib example using LLDB on Linux. Startup an LLDB session using the <span class="font-tt">fib.exe</span> from earlier. Note this session uses Ubuntu 24.04 LTS on ARM64 with OCaml 5.4.</p><pre>$ lldb ./fib.exe
Current executable set to 'fib.exe' (aarch64).
(lldb)
</pre><p>
Breakpoints can be set using the OCaml mangled names or using a combination of file name and line number. For example:</p><pre>(lldb) breakpoint set -n camlFib.fib        # press tab for autocomplete
(lldb) breakpoint set -n camlFib.fib_271
Breakpoint 2: where = fib.exe`camlFib.fib_271 + 80, address = 0x0000000000052360
(lldb) breakpoint set -f fib.ml -l 7         # breakpoint for line 7 in fib.ml
Breakpoint 2: where = fib.exe`camlFib.main_272, address = 0x0000000000051088
(lldb)
</pre><p>
Now we can run the program.</p><pre>(lldb) run
...
Process 11391 stopped
* thread #1, name = 'fib.exe', stop reason = breakpoint 2.1
    frame #0: 0x0000aaaaaaaf1088 fib.exe`camlFib.main_272 at fib.ml:7
   4   	  else if n = 1 then 1
   5   	  else fib (n-1) + fib (n-2)
   6
-&gt; 7   	let main () =
   8   	  let r = fib 20 in
   9   	  Printf.printf "fib(20) = %d" r
   10
...
(lldb) continue
Process 28032 resuming
Process 28032 stopped
* thread #1, name = 'fib.exe', stop reason = breakpoint 2.1
    frame #0: 0x0000aaaaaaaf2360 fib.exe`camlFib.fib_271 at fib.ml:5
   2   	let rec fib n =
   3   	  if n = 0 then 0
   4   	  else if n = 1 then 1
-&gt; 5   	  else fib (n-1) + fib (n-2)
   6
   7   	let main () =
   8   	  let r = fib 20 in

(lldb) bt               # Print a backtrace
* thread #1, name = 'fib.exe', stop reason = breakpoint 2.1
  * frame #0: 0x0000aaaaaaaf2360 fib.exe`camlFib.fib_271 at fib.ml:5
    frame #1: 0x0000aaaaaaaf23d0 fib.exe`camlFib.main_273 at fib.ml:8
    frame #2: 0x0000aaaaaaaf2490 fib.exe`camlFib.entry at fib.ml:11
    frame #3: 0x0000aaaaaaaef748 fib.exe`caml_program + 480
    frame #4: 0x0000aaaaaab4ab90 fib.exe`caml_start_program + 132
    frame #5: 0x0000aaaaaab4a5f8 fib.exe`caml_startup_common [inlined] caml_startup_common(pooling=-1430712272, argv=0x0000000000000010) at startup_nat.c:127:9
    frame #6: 0x0000aaaaaab4a528 fib.exe`caml_startup_common(argv=0x0000000000000010, pooling=-1430712272) at startup_nat.c:86:7
    frame #7: 0x0000aaaaaab4a670 fib.exe`caml_main [inlined] caml_startup_exn(argv=&lt;unavailable&gt;) at startup_nat.c:134:10
    frame #8: 0x0000aaaaaab4a66c fib.exe`caml_main [inlined] caml_startup(argv=&lt;unavailable&gt;) at startup_nat.c:139:15
    frame #9: 0x0000aaaaaab4a66c fib.exe`caml_main(argv=&lt;unavailable&gt;) at startup_nat.c:146:3
    frame #10: 0x0000aaaaaaaef3d0 fib.exe`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at main.c:37:3
    frame #11: 0x0000fffff7d784c4 libc.so.6`__libc_start_call_main(main=(fib.exe`main at main.c:31:1), argc=1, argv=0x0000fffffffffc98) at libc_start_call_main.h:58:16
    frame #12: 0x0000fffff7d78598 libc.so.6`__libc_start_main_impl(main=0x0000aaaaaaba0e68, argc=1, argv=0x0000fffffffffc98, init=&lt;unavailable&gt;, fini=&lt;unavailable&gt;, rtld_fini=&lt;unavailable&gt;, stack_end=&lt;unavailable&gt;) at libc-start.c:360:3
    frame #13: 0x0000aaaaaaaef470 fib.exe`_start + 48
</pre><p>
There is basic support for printing OCaml values using the built-in Python scripting in LLDB and <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/lldb.py">tools/lldb.py</a>. Either find that file in your opam switch e.g. <span class="font-tt"> /.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/lldb.py</span> or download it from github. Then load it into LLDB using <span class="font-tt">command</span>.</p><pre>(lldb) command script import ~/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/lldb.py
OCaml support module loaded. Values of type 'value' will now
print as OCaml values, and an 'ocaml' command is available for
heap exploration (see 'help ocaml' for more information).
(lldb)  p (value)$x0
(value) 41 caml:20
(lldb)
</pre><p>
Note: above we are using an ARM64 Linux machine, so our first argument is passed in the first register <span class="font-tt">x0</span>.</p><p>We can also print out all kinds of OCaml values. Reusing the <span class="font-tt">test_blocks.exe</span> program, startup a new LLDB session:</p><pre>$ lldb ./test_blocks.exe
...
(lldb) command script import ~/.opam/5.4.0/.opam-switch/sources/ocaml-compiler.5.4.0/tools/gdb.py
OCaml support module loaded. Values of type 'value' will now
print as OCaml values, and an 'ocaml' command is available for
heap exploration (see 'help ocaml' for more information).
(lldb) breakpoint set -n camlTest_blocks.main_274
Breakpoint 1: where = test_blocks.exe`camlTest_blocks.main_274 + 44, address = 0x000000000001a6fc
(lldb) run
...
Process 15536 stopped
* thread #1, name = 'test_blocks.exe', stop reason = breakpoint 1.1
    frame #0: 0x0000aaaaaaaba6fc test_blocks.exe`camlTest_blocks.main_274 at test_blocks.ml:5
   2   	type t = {s : string; i : int}
   3
   4   	let main a b =
-&gt; 5   	  print_endline "Hello, world!";
   6   	  print_endline a;
   7   	  print_endline b.s
   8
...
(lldb) p (value)$x0
(value) 187649984957416 caml(-):'Hello, world!'&lt;13&gt;
(lldb) p (value)$x1
(value) 187649984957360 caml(-):('bar', 42)
</pre><p>
Here we use the ARM64 registers named <span class="font-tt">$x0</span> and <span class="font-tt">$x1</span> to access the first and second arguments to a function. This follows the OCaml calling convention on ARM64 where <span class="font-tt">$x0</span> to <span class="font-tt">$x15</span> hold OCaml function arguments. Consult the <span class="font-tt">asmcomp/&lt;ARCH&gt;/proc.ml</span> file for a specific architecture for further information about OCaml calling conventions.</p><p>LLDB supports a feature for specifying how to find the sources. In an LLDB session, using <span class="font-tt">settings set target.source-map /tmp/build /my/src/path</span> remaps the build directory to a source directory and supports multiple pairs of <span class="font-tt">from to</span>.</p><p>For example, copying the source file <span class="font-tt">fib.ml</span> to <span class="font-tt">/tmp/fib.ml</span> and using an opam switch for OCaml 5.4.</p><pre>$ lldb ./fib.exe
(lldb) target create "./fib.exe"
Current executable set to '/home/user/fib.exe' (x86_64).
(lldb) br s -n camlStdlib__Printf.fprintf_431
Breakpoint 1: where = fib.exe`camlStdlib__Printf.fprintf_431 + 16, address = 0x000000000007ddb0
(lldb) br s -f fib.ml -l 9
Breakpoint 2: where = fib.exe`camlFib.main_276 + 66, address = 0x00000000000482c2
(lldb) run
Process 95112 launched: '/home/user/fib.exe' (x86_64)
Process 95112 stopped
* thread #1, name = 'fib.exe', stop reason = breakpoint 1.1
    frame #0: 0x00005555555d1db0 fib.exe`camlStdlib__Printf.fprintf_431 at printf.ml:27:21
# No source listing displayed for printf.ml file.
$ settings set target.source-map /home/user/ /tmp /home/user/.opam/5.4.0/.opam-switch/build/ocaml-variants.5.4.0/ /home/user/.opam/5.4.0/.opam-switch/sources/ocaml-variants.5.4.0/
</pre>
<h3 class="subsection" id="ss:native-debugger-lldb-commands"><a class="section-anchor" href="#ss:native-debugger-lldb-commands" aria-hidden="true">﻿</a>21.4.1 LLDB Commands</h3>
<p>Summary of interesting OCaml specific LLDB commands:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">breakpoint set -n </span></span><span class="font-it">symbol</span></span></dt><dd class="dd-description">
Set a breakpoint at code location matching <span class="font-it">symbol</span>, e.g, Using the mangled OCaml name.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">breakpoint set -f </span></span><span class="font-it">filename</span><span class="machine"><span class="font-tt"> -l </span></span><span class="font-it">linenum</span></span></dt><dd class="dd-description">
Set a breakpoint at <span class="font-it">linenum</span> in <span class="font-it">filename</span>, e.g., <span class="font-tt">fib.ml:7</span></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">breakpoint set -a </span></span><span class="font-it">address</span></span></dt><dd class="dd-description">
Set a breakpoint on a memory <span class="font-it">address</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">backtrace</span></span></span></dt><dd class="dd-description">
Print the backtrace of the entire stack. This will include OCaml source references identifying which stack frame maps to a source location.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">disassemble</span></span></span></dt><dd class="dd-description">
Disassemble specified instructions in the current target. Useful options include <span class="font-tt">-n</span> plus mangled OCaml name to disassemble a specific function and <span class="font-tt">-a</span> plus an address to disassemble function containing this address.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">frame info</span></span></span></dt><dd class="dd-description">
List information about the current stack frame in the current thread.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">source</span></span></span></dt><dd class="dd-description">
Commands for examining source code described by debug information for the current target process.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">settings set target.source-map</span></span><span class="font-it">from</span> <span class="font-it">to</span></span></dt><dd class="dd-description">
Remaps <span class="font-it">from</span> source paths <span class="font-it">to</span> a new source path which is used when locating source code to display alongside a debugged program. Multiple pairs of <span class="font-it">from</span> <span class="font-it">to</span> mappings are supported.</dd></dl><p>In general the features described above work with OCaml, failing that LLDB will fall back to assembly language debugging. LLDB is expected to work on all supported Linux architectures.

</p>
<hr>
<a href="debugger.html"><img src="previous_motif.svg" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.svg" alt="Up"></a>
<a href="profil.html"><img src="next_motif.svg" alt="Next"></a>
</body>
</html>
