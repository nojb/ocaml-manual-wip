<!DOCTYPE html>
<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.36">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>12.26 Labeled tuples</title>
</head>
<body>
<a href="arrayliterals.html"><img src="previous_motif.svg" alt="Previous"></a>
<a href="extn.html"><img src="contents_motif.svg" alt="Up"></a>
<a href="externaltypes.html"><img src="next_motif.svg" alt="Next"></a>
<hr>
<h2 class="section" id="s:labeled-tuples"><a class="section-anchor" href="#s:labeled-tuples" aria-hidden="true">﻿</a>12.26 Labeled tuples</h2>
<p>(Introduced in OCaml 5.4)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> [<a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>] <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> { <span class="syntax-token">*</span> [<a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>]<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> }<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> [<span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>] <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> { <span class="syntax-token">,</span> [<span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>] <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> }<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> [<span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>] <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> { <span class="syntax-token">,</span> [<span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>] <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> }<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Since OCaml 5.4, tuple fields are optionally labeled. This feature is
conceptually dual to labeled function arguments, allowing you to give a helpful
name to constructed values where labeled function arguments permit giving a
helpful name to parameters.</p><p>Here is a motivating example where we want to compute two values from a list and
be careful not to mix them up:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> sum_and_product ints =
  <span class="ocamlkeyword">let</span> init = ~sum:0, ~product:1 <span class="ocamlkeyword">in</span>
  List.fold_left (<span class="ocamlkeyword">fun</span> (~sum, ~product) elem -&gt;
    <span class="ocamlkeyword">let</span> sum = elem + sum <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> product = elem * product <span class="ocamlkeyword">in</span>
    ~sum, ~product) init ints</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum_and_product : int list -&gt; sum:int * product:int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>This example shows the use of labeled tuples in types and patterns. They may be
punned like record elements or function arguments.</p><p>In types, tuple labels are written similarly to function argument labels. For
example, the function argument to <span class="machine"><span class="font-tt">fold_left</span></span> in the previous example has the type:</p><pre>(sum:int * product:int) -&gt; int -&gt; sum:int * product:int
</pre><p>
Labeled tuples can be useful anytime you want to use names to explain or
disambiguate the elements of a tuple, but declaring a new record feels too
heavy.</p><p>Tuples may be partially labeled, which can be useful when some elements of the
tuple share a type and need disambiguation, but others don’t. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> min_max_avg = min:int * max:int * float</div></div>

</div><h4 class="subsubsection" id="sss:labledtuples-reordering"><a class="section-anchor" href="#sss:labledtuples-reordering" aria-hidden="true">﻿</a>Reordering and partial patterns</h4>
<p>Like records, labeled tuple patterns may be reordered or partial. The compiler
only supports reordering / partial matching when it knows the type of the
pattern from its context.</p><p>So, for example, we can write:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> lt = ~x:0, ~y:42
<span class="ocamlkeyword">let</span> twice_y = <span class="ocamlkeyword">let</span> ~y, .. = lt <span class="ocamlkeyword">in</span> y * 2</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lt : x:int * y:int = (~x:0, ~y:42)
<span class="ocamlkeyword">val</span> twice_y : int = 84</div></div>

</div><p>When the type is not known (in the same sense that we require a type to be known
to disambiguate among constructors), the compiler will reject a partial
pattern. For example, this program</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> get_y t =
  <span class="ocamlkeyword">let</span> <span class="ocamlhighlight">~y, ..</span> = t <span class="ocamlkeyword">in</span>
  y</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Could not determine the type of this partial tuple pattern.</div></div>

</div><p>This example could be fixed by adding a type annotation to the function’s parameter.</p><p>Labels may not be repeated in a tuple. However, unlabeled elements can be
thought of as all sharing the same unique label. When matching on such a tuple,
the first unlabeled element in the pattern is bound to the first unlabeled
element in the value, and so on. As a result, it’s also possible to partially
match on an unlabeled tuple to retrieve the first few elements.</p><h4 class="subsubsection" id="sss:labledtuples-limitations"><a class="section-anchor" href="#sss:labledtuples-limitations" aria-hidden="true">﻿</a>Limitations</h4>
<p>Parentheses are necessary to disambiguate functions types with labeled arguments
from function types with labeled tuple arguments when the first element of the
tuple has a label.</p><p>Unlike records, reordering is not supported in labeled tuple expressions, even
when the type is known. This is similar to the way the function definition for a
function with labeled arguments must bind the arguments in the same order as the
type.</p><p>Labeled tuples do not support projection (extracting an element of the tuple by
label).</p><h4 class="subsubsection" id="sss:labledtuples-smlrelation"><a class="section-anchor" href="#sss:labledtuples-smlrelation" aria-hidden="true">﻿</a>Relationship to flexible records</h4>
<p>Labeled tuples are similar in spirit to SML’s flexible records. The primary
difference is that SML records are canonically ordered based on label name,
while labeled tuples are not. So, for example, <span class="machine"><span class="font-tt">x:int * y:bool</span></span> and <span class="machine"><span class="font-tt">y:bool * x:int</span></span> are different types in OCaml, corresponding to two different orderings of
the fields in the runtime block. In SML, the corresponding record types are
considered equal and the runtime block is always ordered with the <span class="machine"><span class="font-tt">x</span></span> field
first.
</p>
<hr>
<a href="arrayliterals.html"><img src="previous_motif.svg" alt="Previous"></a>
<a href="extn.html"><img src="contents_motif.svg" alt="Up"></a>
<a href="externaltypes.html"><img src="next_motif.svg" alt="Next"></a>
</body>
</html>
